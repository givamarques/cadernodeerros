<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../style.css">
    <script src="../scripts.js"></script>
    <title>Qualidade de Software</title>
</head>
<body>
    <h1>Qualidade de Software</h1>

    <h2>1. Metodologias de Desenvolvimento de Software</h2>
    <p><strong>Metodologias de desenvolvimento de software</strong> são abordagens estruturadas para planejar, criar, testar e entregar software. Elas ajudam a garantir a qualidade e eficiência do processo de desenvolvimento.</p>

    <h2>2. Processo Unificado</h2>
    <p><strong>Processo Unificado</strong> é uma metodologia que define etapas e disciplinas para o desenvolvimento de software, com foco em um ciclo de vida iterativo e incremental. Ele visa melhorar a qualidade do software ao longo de suas fases.</p>

    <h2>3. Metodologias Ágeis</h2>
    <p><strong>Metodologias ágeis</strong> são abordagens que focam em entregas rápidas e contínuas, adaptação às mudanças e colaboração entre equipes. Exemplos incluem Scrum e Kanban.</p>

    <h2>4. Métricas e Estimativas de Software</h2>
    <p><strong>Métricas e estimativas de software</strong> são utilizadas para medir o progresso, qualidade e esforço necessário para desenvolver um software, ajudando no planejamento e no controle do projeto.</p>
    <br>
    <h2>5. Análise por Pontos de Função</h2>
    <p><strong>Análise por pontos de função</strong> é uma técnica para medir o tamanho funcional de um software com base nas funcionalidades que ele fornece ao usuário, sendo usada para estimar o esforço de desenvolvimento.</p>
    <h2>Pontos de Função vs. Story Points</h2>

<p><strong>Pontos de Função</strong> é uma métrica tradicional de tamanho de software que se baseia em características funcionais do sistema, como entradas, saídas, consultas, interfaces e arquivos. É um método mais detalhado e objetivo, mas pode ser mais demorado e complexo de aplicar.</p>
<h2>Categorias de Funções na Análise por Pontos de Função</h2>

    <p>As principais categorias de funções medidas na APF são:</p>

    <h3>Funções de Transação (FT)</h3>
    <p>Representam as funções que processam dados, como:</p>
    <ul>
        <li><strong>Entradas:</strong> Dados inseridos no sistema pelo usuário.</li>
        <li><strong>Saídas:</strong> Informações geradas pelo sistema e apresentadas ao usuário.</li>
        <li><strong>Consultas:</strong> Pesquisas de dados armazenados no sistema.</li>
        <li><strong>Interfaces Externas:</strong> Interações com outros sistemas ou dispositivos.</li>
        <li><strong>Conversões:</strong> Processos de transformação de dados de um formato para outro.</li>
    </ul>

    <h3>Funções de Arquivo Lógico (FAL)</h3>
    <p>Representam os arquivos de dados que armazenam informações utilizadas pelas funções de transação.</p>

    <p>Além dessas categorias básicas, a APF também considera outros elementos:</p>
    <ul>
        <li><strong>Complexidade:</strong> Cada função é classificada em diferentes níveis de complexidade, o que influencia na contagem final de pontos de função.</li>
        <li><strong>Fator de Ajuste:</strong> Um fator que pode ser aplicado para ajustar a contagem de pontos de função, considerando características gerais do sistema que não são diretamente relacionadas às funções, como desempenho, confiabilidade, etc.</li>
    </ul>
<p><strong>Story Points</strong>, por outro lado, são uma métrica ágil que se concentra na complexidade relativa de uma tarefa do ponto de vista da equipe de desenvolvimento. Eles são uma medida subjetiva que leva em consideração fatores como:</p>

<ul>
    <li>Complexidade: Quão difícil é implementar a tarefa?</li>
    <li>Incerteza: Quão bem entendemos os requisitos?</li>
    <li>Dependências: Quantas outras tarefas dependem desta?</li>
    <li>Risco: Quais os riscos envolvidos na implementação?</li>
</ul>

<h3>Por que usar Story Points em Agile?</h3>

<ul>
    <li><strong>Agilidade:</strong> Story points permitem que as equipes estimem rapidamente o trabalho e se adaptem a mudanças frequentes.</li>
    <li><strong>Foco no cliente:</strong> Ao se concentrar em funcionalidades (user stories), os story points ajudam a manter o foco nas necessidades do cliente.</li>
    <li><strong>Flexibilidade:</strong> A escala dos story points é relativa, permitindo que as equipes ajustem as estimativas ao longo do projeto.</li>
    <li><strong>Colaboração:</strong> A estimativa de story points é geralmente feita em conjunto pela equipe, promovendo o consenso e o alinhamento.</li>
</ul>

<h3>Quando usar Pontos de Função?</h3>

<ul>
    <li><strong>Contratos:</strong> Pontos de função podem ser usados para definir contratos e orçamentos de projetos de software.</li>
    <li><strong>Comparação de projetos:</strong> Eles podem ser úteis para comparar o tamanho de diferentes projetos.</li>
    <li><strong>Planejamento de longo prazo:</strong> Pontos de função podem fornecer uma estimativa mais precisa para projetos de longo prazo.</li>
</ul>

<h3>Em resumo:</h3>
<ul>
    <li><strong>Story Points:</strong> Ideal para equipes ágeis que buscam flexibilidade e foco no cliente.</li>
    <li><strong>Pontos de Função:</strong> Mais adequado para projetos tradicionais com requisitos bem definidos e necessidade de estimativas precisas e detalhadas.</li>
</ul>

<p>Em muitos casos, as equipes ágeis combinam ambas as métricas: utilizam story points para o planejamento ágil e pontos de função para relatórios gerenciais e comparações de projetos.</p>

<p><strong>Qual a melhor opção para o seu projeto?</strong></p>
<p>A escolha entre pontos de função e story points dependerá das características do seu projeto, da sua equipe e dos seus objetivos. É importante avaliar as vantagens e desvantagens de cada abordagem para tomar a decisão mais adequada.</p>
<br>
<h2>Story Points</h2>

    <p>Story points are a relative unit of measure used in Agile software development to estimate the effort required to complete a user story. They're a way to prioritize tasks and track progress without committing to specific timeframes.</p>
    
    <h3>Key points about story points:</h3>
    
    <ul>
        <li><strong>Relative measure:</strong> Story points don't represent hours or days. They're a comparison between stories.</li>
        <li><strong>Team-specific:</strong> The meaning of a story point varies from team to team.</li>
        <li><strong>Based on complexity and uncertainty:</strong> Factors like complexity, dependencies, and uncertainty influence the number of story points assigned.</li>
        <li><strong>Used for planning and tracking:</strong> They help teams plan iterations and track progress towards goals.</li>
        <li><strong>Adjusted as needed:</strong> Story points can be adjusted during development if estimates were inaccurate.</li>
    </ul>
    
    <h3>How to estimate story points:</h3>
    
    <p>There are various techniques to estimate story points, including:</p>
    
    <ul>
        <li><strong>Planning Poker:</strong> Teams use cards with numbers to anonymously estimate stories.</li>
        <li><strong>T-shirt sizing:</strong> Stories are categorized as small, medium, large, or extra large.</li>
        <li><strong>Fibonacci sequence:</strong> Using numbers from the Fibonacci sequence (1, 2, 3, 5, 8, 13, ...) for estimation.</li>
    </ul>
    
    <h3>Benefits of using story points:</h3>
    
    <ul>
        <li><strong>Improved accuracy:</strong> Relative estimates are often more accurate than absolute time estimates.</li>
        <li><strong>Reduced risk:</strong> By focusing on relative effort, teams can mitigate risks associated with fixed deadlines.</li>
        <li><strong>Increased flexibility:</strong> Story points allow for adjustments in response to changing priorities or unforeseen challenges.</li>
        <li><strong>Improved collaboration:</strong> Estimating together fosters team understanding and alignment.</li>
    </ul>
    
    <p>In conclusion, story points are a valuable tool in Agile development for estimating, prioritizing, and tracking work. By using them effectively, teams can improve their ability to deliver value consistently and efficiently.</p>
    <br>
    <h2>6. MPS-BR</h2>
    <p><strong>MPS-BR</strong> (Melhoria de Processo do Software Brasileiro) é um modelo de melhoria de processos de software adaptado à realidade das empresas brasileiras, que visa aumentar a qualidade e a competitividade dos produtos de software.</p>
    <h2>CMMI (Capability Maturity Model Integration)</h2>
    <p><strong>Modelo Internacional:</strong> O CMMI é um modelo amplamente utilizado em todo o mundo, estabelecendo níveis de maturidade para as organizações de desenvolvimento de software.</p>
    <p><strong>Foco nos Processos:</strong> Ele se concentra em melhorar os processos de desenvolvimento, desde a definição de requisitos até a entrega do software.</p>
    <p><strong>Relação com a QoS:</strong> O CMMI contribui para a QoS ao:</p>
    <ul>
        <li><strong>Estabelecer práticas padronizadas:</strong> Define práticas recomendadas para cada nível de maturidade, garantindo que os processos sejam consistentes e eficazes.</li>
        <li><strong>Promover a melhoria contínua:</strong> Incentiva as organizações a buscarem níveis de maturidade cada vez mais altos, o que resulta em uma melhoria contínua na qualidade dos produtos e serviços.</li>
        <li><strong>Gerenciar riscos:</strong> Ajuda a identificar e mitigar riscos, reduzendo a probabilidade de defeitos e falhas no software.</li>
    </ul>
    
    <h2>MPS.BR (Melhoria de Processo de Software Brasileiro)</h2>
    <p><strong>Modelo Nacional:</strong> O MPS.BR é um modelo brasileiro que se baseia no CMMI, adaptando-o à realidade das empresas brasileiras.</p>
    <p><strong>Foco na Melhoria:</strong> Assim como o CMMI, o MPS.BR visa a melhoria contínua dos processos de software.</p>
    <p><strong>Relação com a QoS:</strong> O MPS.BR contribui para a QoS ao:</p>
    <ul>
        <li><strong>Promover a cultura de qualidade:</strong> Incentiva a adoção de práticas de qualidade em todas as fases do desenvolvimento de software.</li>
        <li><strong>Adaptar-se à realidade brasileira:</strong> Considera as particularidades do mercado brasileiro, tornando-o mais relevante para as empresas nacionais.</li>
        <li><strong>Integrar as melhores práticas:</strong> Combina as melhores práticas internacionais com as necessidades específicas do mercado brasileiro.</li>
    </ul>
    <br>
    <h2>7. Testes Unitários</h2>
    <p><strong>Testes unitários</strong> são testes automatizados que verificam o funcionamento correto de pequenas partes do código, geralmente funções ou métodos, garantindo que cada unidade do software funcione conforme esperado.</p>
    <h2>O que são testes unitários?</h2>
    <p>Em desenvolvimento de software, testes unitários são uma técnica de garantia de qualidade que envolve testar individualmente cada unidade de código (geralmente uma função ou método) para garantir que ela funciona como esperado. É como verificar se cada peça de um quebra-cabeça encaixa perfeitamente antes de montar a imagem completa.</p>
    
    <h3>Por que são importantes?</h3>
    <ul>
        <li><strong>Detecção precoce de bugs:</strong> Ao testar cada unidade isoladamente, você identifica e corrige problemas rapidamente, antes que eles se propaguem para outras partes do sistema.</li>
        <li><strong>Melhora da qualidade do código:</strong> Escrever testes unitários força você a pensar mais cuidadosamente sobre o design do seu código, tornando-o mais modular, coeso e fácil de manter.</li>
        <li><strong>Aumento da confiança:</strong> Com testes unitários, você tem mais confiança ao fazer alterações no código, pois sabe que os testes irão identificar qualquer impacto negativo.</li>
        <li><strong>Facilita a refatoração:</strong> Ao ter uma boa cobertura de testes, você pode refatorar o código com mais segurança, sabendo que os testes irão garantir que a funcionalidade não foi comprometida.</li>
        <li><strong>Agiliza o desenvolvimento:</strong> Testes unitários automatizados economizam tempo, pois você não precisa executar manualmente os testes a cada alteração.</li>
    </ul>
    
    <h3>Como funcionam os testes unitários?</h3>
    <ul>
        <li><strong>Isolamento:</strong> Cada teste se concentra em uma única unidade de código, sem dependências externas.</li>
        <li><strong>Verificação:</strong> O teste compara o resultado real da execução da unidade com o resultado esperado.</li>
        <li><strong>Automatização:</strong> Os testes são executados automaticamente, geralmente como parte do processo de integração contínua.</li>
    </ul>
    
    <h4>Exemplo simples em Python:</h4>
    <pre><code style="font-size: large;">
    def soma(a, b):
        return a + b
    
    def test_soma():
        assert soma(2, 3) == 5
        assert soma(-1, 1) == 0
    </code></pre>
    
    <h3>Princípios de um bom teste unitário:</h3>
    <ul>
        <li><strong>Independente:</strong> Cada teste deve ser independente dos outros.</li>
        <li><strong>Repetitivo:</strong> Um teste deve sempre produzir o mesmo resultado quando executado nas mesmas condições.</li>
        <li><strong>Auto verificável:</strong> O teste deve ter um mecanismo para determinar se passou ou falhou.</li>
        <li><strong>Isolado:</strong> O teste não deve depender de fatores externos, como bancos de dados ou serviços web.</li>
        <li><strong>Rápido:</strong> Os testes unitários devem ser executados rapidamente para fornecer feedback rápido aos desenvolvedores.</li>
    </ul>
    
    <h3>Ferramentas para testes unitários:</h3>
    <ul>
        <li><strong>JUnit:</strong> Para Java</li>
        <li><strong>pytest:</strong> Para Python</li>
        <li><strong>Jest:</strong> Para JavaScript</li>
        <li><strong>NUnit:</strong> Para .NET</li>
    </ul>
    
    <p><strong>Conclusão</strong></p>
    <p>Testes unitários são uma prática fundamental para garantir a qualidade do software. Ao investir tempo na criação de testes unitários, você estará construindo um software mais robusto, confiável e fácil de manter.</p>
    
    <p>Gostaria de aprender mais sobre algum aspecto específico dos testes unitários, como a escolha de ferramentas ou a criação de testes eficazes?</p>
    <ul>
        <li>Cobertura de código: Como garantir que todos os seus códigos estão sendo testados?</li>
        <li>Testes de integração: Qual a diferença entre testes unitários e de integração?</li>
        <li>TDD (Test-Driven Development): Como escrever testes antes do código?</li>
        <li>Mocks e stubs: Como simular dependências em seus testes?</li>
    </ul>
</body>
</html>